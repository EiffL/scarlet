

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>scarlet.transformations &mdash; scarlet  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="scarlet  documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> scarlet
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user_docs.html">User Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">scarlet</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>scarlet.transformations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scarlet.transformations</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>

<span class="c1"># global cache to hold all transformation matrices</span>
<span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

<span class="k">def</span> <span class="nf">check_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">cache</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="GammaOp"><a class="viewcode-back" href="../../transformations.html#scarlet.transformations.GammaOp">[docs]</a><span class="k">class</span> <span class="nc">GammaOp</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Combination of Linear (x,y) Transformation and PSF Convolution</span>

<span class="sd">    Since the translation operators and PSF convolution operators both act</span>
<span class="sd">    on the deconvolved, centered S matrix, we can instead think of the translation</span>
<span class="sd">    operators translating the PSF convolution kernel, making a single transformation</span>
<span class="sd">    Gamma = Ty.P.Tx, where Tx,Ty are the translation operators and P is the PSF</span>
<span class="sd">    convolution operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">psf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset_int</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape: tuple</span>
<span class="sd">            Shape of the Source frame</span>
<span class="sd">        psf: array-like, default=`None`</span>
<span class="sd">            PSF image in either a single band (used for all images)</span>
<span class="sd">            or an array/list of images with a PSF image for each band.</span>
<span class="sd">        offset_int: int, default=`None`</span>
<span class="sd">            The translation matrices only care about fractional offsets.</span>
<span class="sd">            Integer offsets are handled in a different way, but are no longer necessary</span>
<span class="sd">            because we are now creating frames around sources.</span>
<span class="sd">            TODO: remove this option</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">offset_int</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset_int</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psf</span> <span class="o">=</span> <span class="n">psf</span>

        <span class="c1"># link to cache and make sure it has Gamma</span>
        <span class="k">global</span> <span class="n">cache</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cache</span><span class="p">[</span><span class="s1">&#39;Gamma&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">cache</span><span class="p">[</span><span class="s1">&#39;Gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="s1">&#39;Gamma&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_make_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">offset_int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build Tx, Ty, P, Gamma</span>

<span class="sd">        To save processing time we separate the diagonal component</span>
<span class="sd">        (which is just an identity matrix) and the off-diagonal</span>
<span class="sd">        component (which is just a band diagonal matrix that is all zeros).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape: tuple</span>
<span class="sd">            Shape of the `~scarlet.Source` frame</span>
<span class="sd">        offset_int: int, default=`None`</span>
<span class="sd">            Integer offset of the translation. See `__init__`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: tuple</span>
<span class="sd">            tx, tx_plus, tx_minus, ty, ty_plus, ty_minus, P</span>
<span class="sd">        tx, ty: `~scipy.sparse` array</span>
<span class="sd">            Sparse arrays that contain the diagonal components of the Tx, Ty matrices</span>
<span class="sd">        tx_plus, ty_plus: `~scipy.sparse` array</span>
<span class="sd">            Sparse arrays that contain the off diagonal components of the Tx, Ty matrices.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([</span><span class="mf">1.</span><span class="p">],</span> <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
        <span class="n">tx_minus</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],</span> <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
        <span class="n">tx_plus</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">],</span><span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">block_diag</span><span class="p">([</span><span class="n">tx</span><span class="p">]</span><span class="o">*</span><span class="n">height</span><span class="p">)</span>
        <span class="n">tx_plus</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">block_diag</span><span class="p">([</span><span class="n">tx_plus</span><span class="p">]</span><span class="o">*</span><span class="n">height</span><span class="p">)</span>
        <span class="n">tx_minus</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">block_diag</span><span class="p">([</span><span class="n">tx_minus</span><span class="p">]</span><span class="o">*</span><span class="n">height</span><span class="p">)</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">height</span><span class="o">*</span><span class="n">width</span>
        <span class="n">ty</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">width</span><span class="p">],</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">ty_minus</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="p">(</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="p">],</span>
                                      <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
        <span class="n">ty_plus</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">],</span> <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="p">(</span><span class="n">offset_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="p">],</span>
                                     <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>

        <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_PSF</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">tx</span><span class="p">,</span><span class="n">tx_plus</span><span class="p">,</span><span class="n">tx_minus</span><span class="p">,</span><span class="n">ty</span><span class="p">,</span><span class="n">ty_plus</span><span class="p">,</span><span class="n">ty_minus</span><span class="p">,</span><span class="n">P</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">offset_int</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the operators to translate source</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pos: array-like</span>
<span class="sd">            (dy,dx) Fractional position in the x and y directions to shift the source.</span>
<span class="sd">        shape: tuple</span>
<span class="sd">            Shape of the `~scarlet.Source` frame</span>
<span class="sd">        offset_int: int, default=`None`</span>
<span class="sd">            Integer offset of the translation. See `__init__`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gamma: list of `~scipy.sparse` arrays</span>
<span class="sd">            Sparse Gamma array for each band, where Gamma=Ty.P.Tx.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">pos</span>
        <span class="k">if</span> <span class="n">offset_int</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset_int</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">offset_int</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">tx</span><span class="p">,</span><span class="n">tx_plus</span><span class="p">,</span><span class="n">tx_minus</span><span class="p">,</span><span class="n">ty</span><span class="p">,</span><span class="n">ty_plus</span><span class="p">,</span><span class="n">ty_minus</span><span class="p">,</span><span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_matrices</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">offset_int</span><span class="p">)</span>
            <span class="n">tx</span><span class="p">,</span> <span class="n">tx_plus</span><span class="p">,</span> <span class="n">tx_minus</span><span class="p">,</span> <span class="n">ty</span><span class="p">,</span> <span class="n">ty_plus</span><span class="p">,</span> <span class="n">ty_minus</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Create Tx</span>
        <span class="k">if</span> <span class="n">dx</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">dtx</span> <span class="o">=</span> <span class="n">tx_minus</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dtx</span> <span class="o">=</span> <span class="n">tx_plus</span>
        <span class="c1"># linear interpolation between centers and offset by one pixel</span>
        <span class="n">Tx</span> <span class="o">=</span> <span class="n">tx</span> <span class="o">-</span> <span class="n">dx</span><span class="o">*</span><span class="n">dtx</span>
        <span class="c1"># Create Ty</span>
        <span class="k">if</span> <span class="n">dy</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">dty</span> <span class="o">=</span> <span class="n">ty_minus</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dty</span> <span class="o">=</span> <span class="n">ty_plus</span>
        <span class="n">Ty</span> <span class="o">=</span> <span class="n">ty</span> <span class="o">-</span> <span class="n">dy</span><span class="o">*</span><span class="n">dty</span>
        <span class="c1"># return Tx, Ty</span>

        <span class="k">if</span> <span class="n">P</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Ty</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
            <span class="n">_gamma</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ty</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tx</span><span class="p">))</span>
            <span class="c1"># simplifies things later on: PSF always comes with B Gamma operators</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">_gamma</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Pb</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ty</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Tx</span><span class="p">))</span> <span class="k">for</span> <span class="n">Pb</span> <span class="ow">in</span> <span class="n">P</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_adapt_PSF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create multiband PSF operator (if necessary)</span>

<span class="sd">        `~scipy.sparse` only works for 2D matrices. Since we have a</span>
<span class="sd">        3rd dimension, the band, we need an adapter to keep track of the</span>
<span class="sd">        PSF operator in different bands.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape: tuple</span>
<span class="sd">            Shape of the `~scarlet.Source` frame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        P: `~scipy.sparse` array or list of `~scipy.sparse` arrays</span>
<span class="sd">            PSF convolution operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">psf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psf</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span> <span class="c1"># single matrix</span>
            <span class="k">return</span> <span class="n">getPSFOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psf</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

        <span class="n">P</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psf</span><span class="p">)):</span>
            <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">getPSFOp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psf</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">shape</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">P</span></div>


<div class="viewcode-block" id="getPSFOp"><a class="viewcode-back" href="../../transformations.html#scarlet.transformations.getPSFOp">[docs]</a><span class="k">def</span> <span class="nf">getPSFOp</span><span class="p">(</span><span class="n">psf</span><span class="p">,</span> <span class="n">imgShape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an operator to convolve intensities with the PSF</span>

<span class="sd">    Given a psf image ``psf`` and the shape of the blended image ``imgShape``,</span>
<span class="sd">    make a banded matrix out of all non-zero pixels in ``psfImg`` that acts as</span>
<span class="sd">    the PSF operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;PSF&quot;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">imgShape</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">psfOp</span> <span class="o">=</span> <span class="n">check_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">imgShape</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>

        <span class="c1"># Calculate the coordinates of the pixels in the psf image above the threshold</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">psf</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># assume all PSF images have odd dimensions and are centered!</span>
        <span class="n">cy</span><span class="p">,</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">psf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">psf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">indices</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cy</span><span class="p">,</span><span class="n">cx</span><span class="p">])</span>

        <span class="c1"># Create the PSF Operator</span>
        <span class="n">offsets</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">slicesInv</span> <span class="o">=</span> <span class="n">getOffsets</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
        <span class="n">psfDiags</span> <span class="o">=</span> <span class="p">[</span><span class="n">psf</span><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="n">psfOp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">psfDiags</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">psfOp</span> <span class="o">=</span> <span class="n">psfOp</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span>

        <span class="c1"># Remove entries for pixels on the left or right edges</span>
        <span class="n">cxRange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">cx</span> <span class="k">for</span> <span class="n">cy</span><span class="p">,</span><span class="n">cx</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
                <span class="c1"># Left edge</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="o">&lt;=</span><span class="n">height</span><span class="p">:</span>
                    <span class="n">psfOp</span><span class="p">[</span><span class="n">width</span><span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># Pixels closer to the left edge</span>
                    <span class="c1"># than the radius of the psf</span>
                    <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">cxRange</span><span class="p">[</span><span class="n">cxRange</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">x_</span> <span class="ow">and</span>
                            <span class="n">width</span><span class="o">*</span><span class="n">h</span><span class="o">-</span><span class="n">x_</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span>
                            <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="n">x_</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span>
                            <span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="o">&lt;=</span><span class="n">height</span>
                        <span class="p">):</span>
                            <span class="n">psfOp</span><span class="p">[</span><span class="n">width</span><span class="o">*</span><span class="n">h</span><span class="o">-</span><span class="n">x_</span><span class="p">,</span> <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="n">x_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Right edge</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="o">&lt;=</span><span class="n">height</span> <span class="ow">and</span> <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">size</span><span class="p">:</span>
                    <span class="n">psfOp</span><span class="p">[</span><span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">cxRange</span><span class="p">[</span><span class="n">cxRange</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="c1"># Near right edge</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="n">x_</span> <span class="ow">and</span>
                            <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">x_</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span>
                            <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="n">x_</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span>
                            <span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="o">&lt;=</span><span class="n">height</span> <span class="ow">and</span>
                            <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="n">x_</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">size</span>
                        <span class="p">):</span>
                            <span class="n">psfOp</span><span class="p">[</span><span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">x_</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">x</span><span class="o">-</span><span class="n">x_</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Return the transpose, which correctly convolves the data with the PSF</span>
        <span class="n">psfOp</span> <span class="o">=</span> <span class="n">psfOp</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>

        <span class="k">global</span> <span class="n">cache</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">psfOp</span>

    <span class="k">return</span> <span class="n">psfOp</span></div>


<span class="k">def</span> <span class="nf">getZeroOp</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Zero&quot;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">check_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># matrix with ones on diagonal shifted by k, here out of matrix: all zeros</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="k">global</span> <span class="n">cache</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span>
    <span class="k">return</span> <span class="n">L</span>

<span class="k">def</span> <span class="nf">getIdentityOp</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Id&quot;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">check_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># matrix with ones on diagonal shifted by k, here out of matrix: all zeros</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">global</span> <span class="n">cache</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span>
    <span class="k">return</span> <span class="n">L</span>

<div class="viewcode-block" id="getSymmetryOp"><a class="viewcode-back" href="../../transformations.html#scarlet.transformations.getSymmetryOp">[docs]</a><span class="k">def</span> <span class="nf">getSymmetryOp</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a linear operator to symmetrize an image</span>

<span class="sd">    Given the ``shape`` of an image, create a linear operator that</span>
<span class="sd">    acts on the flattened image to return its symmetric version.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Symm&quot;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">symmetryOp</span> <span class="o">=</span> <span class="n">check_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sidx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">symmetryOp</span> <span class="o">=</span> <span class="n">getIdentityOp</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">symmetryOp</span> <span class="o">-=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">),(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sidx</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">size</span><span class="p">))</span>
        <span class="k">global</span> <span class="n">cache</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">symmetryOp</span>
    <span class="k">return</span> <span class="n">symmetryOp</span></div>

<div class="viewcode-block" id="getOffsets"><a class="viewcode-back" href="../../transformations.html#scarlet.transformations.getOffsets">[docs]</a><span class="k">def</span> <span class="nf">getOffsets</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the offset and slices for a sparse band diagonal array</span>

<span class="sd">    For an operator that interacts with its neighbors we want a band diagonal matrix,</span>
<span class="sd">    where each row describes the 8 pixels that are neighbors for the reference pixel</span>
<span class="sd">    (the diagonal). Regardless of the operator, these 8 bands are always the same,</span>
<span class="sd">    so we make a utility function that returns the offsets (passed to scipy.sparse.diags).</span>

<span class="sd">    See `diagonalizeArray` for more on the slices and format of the array used to create</span>
<span class="sd">    NxN operators that act on a data vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use the neighboring pixels by default</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">x</span> <span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">]</span>
    <span class="n">slicesInv</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">slicesInv</span></div>

<div class="viewcode-block" id="diagonalizeArray"><a class="viewcode-back" href="../../transformations.html#scarlet.transformations.diagonalizeArray">[docs]</a><span class="k">def</span> <span class="nf">diagonalizeArray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert an array to a matrix that compares each pixel to its neighbors</span>

<span class="sd">    Given an array with length N, create an 8xN array, where each row will be a</span>
<span class="sd">    diagonal in a diagonalized array. Each column in this matrix is a row in the larger</span>
<span class="sd">    NxN matrix used for an operator, except that this 2D array only contains the values</span>
<span class="sd">    used to create the bands in the band diagonal matrix.</span>

<span class="sd">    Because the off-diagonal bands have less than N elements, ``getOffsets`` is used to</span>
<span class="sd">    create a mask that will set the elements of the array that are outside of the matrix to zero.</span>

<span class="sd">    ``arr`` is the vector to diagonalize, for example the distance from each pixel to the peak,</span>
<span class="sd">    or the angle of the vector to the peak.</span>

<span class="sd">    ``shape`` is the shape of the original image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected either a 2D array or a 1D array and a shape&quot;</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span>

    <span class="c1"># We hard code 8 rows, since each row corresponds to a neighbor</span>
    <span class="c1"># of each pixel.</span>
    <span class="n">diagonals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">offsets</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">slicesInv</span> <span class="o">=</span> <span class="n">getOffsets</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
        <span class="n">diagonals</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">slicesInv</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">slicesInv</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Create a mask to hide false neighbors for pixels on the edge</span>
    <span class="c1"># (for example, a pixel on the left edge should not be connected to the</span>
    <span class="c1"># pixel to its immediate left in the flattened vector, since that pixel</span>
    <span class="c1"># is actual the far right pixel on the row above it).</span>
    <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">height</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">height</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">height</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">height</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">height</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">diagonals</span><span class="p">,</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="diagonalsToSparse"><a class="viewcode-back" href="../../transformations.html#scarlet.transformations.diagonalsToSparse">[docs]</a><span class="k">def</span> <span class="nf">diagonalsToSparse</span><span class="p">(</span><span class="n">diagonals</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a diagonalized array into a sparse diagonal matrix</span>

<span class="sd">    ``diagonalizeArray`` creates an 8xN array representing the bands that describe the</span>
<span class="sd">    interactions of a pixel with its neighbors. This function takes that 8xN array and converts</span>
<span class="sd">    it into a sparse diagonal matrix.</span>

<span class="sd">    See `diagonalizeArray` for the details of the 8xN array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="n">offsets</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span> <span class="n">slicesInv</span> <span class="o">=</span> <span class="n">getOffsets</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
    <span class="n">diags</span> <span class="o">=</span> <span class="p">[</span><span class="n">diag</span><span class="p">[</span><span class="n">slicesInv</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">diag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diagonals</span><span class="p">)]</span>
    <span class="n">diagonalArr</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">diags</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">diagonalArr</span></div>

<div class="viewcode-block" id="getRadialMonotonicWeights"><a class="viewcode-back" href="../../transformations.html#scarlet.transformations.getRadialMonotonicWeights">[docs]</a><span class="k">def</span> <span class="nf">getRadialMonotonicWeights</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">useNearest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">minGradient</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create the weights used for the Radial Monotonicity Operator</span>

<span class="sd">    This version of the radial monotonicity operator selects all of the pixels closer to the peak</span>
<span class="sd">    for each pixel and weights their flux based on their alignment with a vector from the pixel</span>
<span class="sd">    to the peak. In order to quickly create this using sparse matrices, its construction is a bit opaque.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;RadialMonotonicWeights&quot;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">useNearest</span><span class="p">,</span> <span class="n">minGradient</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cosNorm</span> <span class="o">=</span> <span class="n">check_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>

        <span class="c1"># Center on the center pixel</span>
        <span class="n">px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">py</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Calculate the distance between each pixel and the peak</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">X</span><span class="p">,</span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">px</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">-</span> <span class="n">py</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Find each pixels neighbors further from the peak and mark them as invalid</span>
        <span class="c1"># (to be removed later)</span>
        <span class="n">distArr</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">diagonalizeArray</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">relativeDist</span> <span class="o">=</span> <span class="p">(</span><span class="n">distance</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">distArr</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">invalidPix</span> <span class="o">=</span> <span class="n">relativeDist</span><span class="o">&lt;=</span><span class="mi">0</span>

        <span class="c1"># Calculate the angle between each pixel and the x axis, relative to the peak position</span>
        <span class="c1"># (also avoid dividing by zero and set the tan(infinity) pixel values to pi/2 manually)</span>
        <span class="n">inf</span> <span class="o">=</span> <span class="n">X</span><span class="o">==</span><span class="mi">0</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tX</span><span class="p">[</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">Y</span><span class="p">,</span><span class="o">-</span><span class="n">tX</span><span class="p">)</span>
        <span class="n">angles</span><span class="p">[</span><span class="n">inf</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Y</span><span class="o">!=</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="n">inf</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Y</span><span class="o">!=</span><span class="mi">0</span><span class="p">)])</span>

        <span class="c1"># Calcualte the angle between each pixel and it&#39;s neighbors</span>
        <span class="n">xArr</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">diagonalizeArray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">yArr</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">diagonalizeArray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xArr</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">X</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">yArr</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">Y</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Avoid dividing by zero and set the tan(infinity) pixel values to pi/2 manually</span>
        <span class="n">inf</span> <span class="o">=</span> <span class="n">dx</span><span class="o">==</span><span class="mi">0</span>
        <span class="n">dx</span><span class="p">[</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">relativeAngles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">relativeAngles</span><span class="p">[</span><span class="n">inf</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dy</span><span class="o">!=</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">relativeAngles</span><span class="p">[</span><span class="n">inf</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dy</span><span class="o">!=</span><span class="mi">0</span><span class="p">)])</span>

        <span class="c1"># Find the difference between each pixels angle with the peak</span>
        <span class="c1"># and the relative angles to its neighbors, and take the</span>
        <span class="c1"># cos to find its neighbors weight</span>
        <span class="n">dAngles</span> <span class="o">=</span> <span class="p">(</span><span class="n">angles</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[:,</span> <span class="kc">None</span><span class="p">]</span><span class="o">-</span><span class="n">relativeAngles</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">cosWeight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dAngles</span><span class="p">)</span>
        <span class="c1"># Mask edge pixels, array elements outside the operator (for offdiagonal bands with &lt; N elements),</span>
        <span class="c1"># and neighbors further from the peak than the reference pixel</span>
        <span class="n">cosWeight</span><span class="p">[</span><span class="n">invalidPix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cosWeight</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">useNearest</span><span class="p">:</span>
            <span class="c1"># Only use a single pixel most in line with peak</span>
            <span class="n">cosNorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cosWeight</span><span class="p">)</span>
            <span class="n">columnIndices</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cosWeight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">maxIndices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cosWeight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">maxIndices</span><span class="o">*</span><span class="n">cosNorm</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">columnIndices</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">cosNorm</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">cosNorm</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">minGradient</span>
            <span class="c1"># Remove the reference for the peak pixel</span>
            <span class="n">cosNorm</span><span class="p">[:,</span><span class="n">px</span><span class="o">+</span><span class="n">py</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normalize the cos weights for each pixel</span>
            <span class="n">normalize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cosWeight</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">normalize</span><span class="p">[</span><span class="n">normalize</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">cosNorm</span> <span class="o">=</span> <span class="p">(</span><span class="n">cosWeight</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="n">normalize</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">cosNorm</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">global</span> <span class="n">cache</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosNorm</span>

    <span class="k">return</span> <span class="n">cosNorm</span></div>

<div class="viewcode-block" id="getRadialMonotonicOp"><a class="viewcode-back" href="../../transformations.html#scarlet.transformations.getRadialMonotonicOp">[docs]</a><span class="k">def</span> <span class="nf">getRadialMonotonicOp</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">useNearest</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">minGradient</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">subtract</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create an operator to constrain radial monotonicity</span>

<span class="sd">    This version of the radial monotonicity operator selects all of the pixels closer to the peak</span>
<span class="sd">    for each pixel and weights their flux based on their alignment with a vector from the pixel</span>
<span class="sd">    to the peak. In order to quickly create this using sparse matrices, its construction is a bit opaque.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;RadialMonotonic&quot;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">useNearest</span><span class="p">,</span> <span class="n">minGradient</span><span class="p">,</span> <span class="n">subtract</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">monotonic</span> <span class="o">=</span> <span class="n">check_cache</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>

        <span class="n">cosNorm</span> <span class="o">=</span> <span class="n">getRadialMonotonicWeights</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">useNearest</span><span class="o">=</span><span class="n">useNearest</span><span class="p">,</span> <span class="n">minGradient</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cosArr</span> <span class="o">=</span> <span class="n">diagonalsToSparse</span><span class="p">(</span><span class="n">cosNorm</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

        <span class="c1"># The identity with the peak pixel removed represents the reference pixels</span>
        <span class="c1"># Center on the center pixel</span>
        <span class="n">px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">py</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Calculate the distance between each pixel and the peak</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">diagonal</span><span class="p">[</span><span class="n">px</span><span class="o">+</span><span class="n">py</span><span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">subtract</span><span class="p">:</span>
            <span class="n">monotonic</span> <span class="o">=</span> <span class="n">cosArr</span><span class="o">-</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">offsets</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">monotonic</span> <span class="o">=</span> <span class="n">cosArr</span>
        <span class="n">monotonic</span> <span class="o">=</span> <span class="n">monotonic</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>

        <span class="k">global</span> <span class="n">cache</span>
        <span class="n">cache</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">monotonic</span>

    <span class="k">return</span> <span class="n">monotonic</span></div>


<span class="c1"># ring-shaped masks around the peak</span>
<span class="k">def</span> <span class="nf">getRingMask</span><span class="p">(</span><span class="n">im_shape</span><span class="p">,</span> <span class="n">peak</span><span class="p">,</span> <span class="n">outer</span><span class="p">,</span> <span class="n">inner</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">flatten</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">height</span><span class="p">,</span><span class="n">width</span> <span class="o">=</span> <span class="n">im_shape</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">height</span><span class="p">))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">inner</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="n">outer</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">flatten</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">mask</span>

<span class="c1"># odd-integer downsampling</span>
<span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">oversampling</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">oversampling</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">oversampling</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">S</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">height</span><span class="p">,</span><span class="n">width</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">height</span> <span class="o">/=</span> <span class="n">oversampling</span>
        <span class="n">width</span> <span class="o">/=</span> <span class="n">oversampling</span>
        <span class="n">Sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">S_</span> <span class="o">=</span> <span class="n">S</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S_</span> <span class="o">=</span> <span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span>
        <span class="c1"># TODO: can we avoid the double loop?</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
                <span class="n">Sd</span><span class="p">[</span><span class="n">h</span><span class="p">,</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">S_</span><span class="p">[</span><span class="n">h</span><span class="o">*</span><span class="n">oversampling</span><span class="p">:(</span><span class="n">h</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">oversampling</span><span class="p">,</span>
                             <span class="n">w</span><span class="o">*</span><span class="n">oversampling</span><span class="p">:(</span><span class="n">w</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">oversampling</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">oversampling</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">Sd</span>

<span class="c1"># construct spin-wave decomposition operator for given list of spin numbers m</span>
<span class="c1"># radial behavior can be specified as appropriate</span>
<div class="viewcode-block" id="getSpinOp"><a class="viewcode-back" href="../../transformations.html#scarlet.transformations.getSpinOp">[docs]</a><span class="k">def</span> <span class="nf">getSpinOp</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">peak</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="mi">21</span><span class="p">,</span> <span class="n">radial_fct</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span><span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot; Spin decomposition operator.</span>

<span class="sd">    The operator maps onto a basis function of R(r) exp(i m phi), where phi is</span>
<span class="sd">    the polar angle wrt to the peak (or, if None, the center of the image).</span>

<span class="sd">    The decomposition is performed in a set of concentric rings of fixed thickness.</span>

<span class="sd">    ms is a list of integers that indicate the requested spin numbers.</span>
<span class="sd">    thickness is the radial separation between the inner and outer ring radius.</span>
<span class="sd">    peak is (an optional) offset of the object from the image center.</span>
<span class="sd">    oversampling determine the higher-resolution grid for the in-pixel</span>
<span class="sd">    integration; it must be odd.</span>
<span class="sd">    radial_fct is the radial part of the spin basis function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">oversampling</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span>

    <span class="n">height</span><span class="p">,</span><span class="n">width</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="k">assert</span> <span class="n">height</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">width</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">peak</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">peak</span> <span class="o">=</span> <span class="p">[</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">width</span><span class="o">*</span><span class="n">oversampling</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">height</span><span class="o">*</span><span class="n">oversampling</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">1.</span><span class="o">/</span><span class="n">oversampling</span> <span class="o">-</span> <span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="mf">1.</span><span class="o">/</span><span class="n">oversampling</span> <span class="o">-</span> <span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># proper treatment of over &amp; downsampling: center pixel location</span>
    <span class="k">if</span> <span class="n">oversampling</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">oversampling</span>
        <span class="n">y</span> <span class="o">-=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">oversampling</span>
    <span class="c1"># convert to polar</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># define series of radial ring-shaped masks (oversampled as well)</span>
    <span class="n">r_limit</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">height</span><span class="o">-</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">width</span><span class="o">-</span><span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">oversampling</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">thickness</span><span class="o">*</span><span class="n">oversampling</span>
    <span class="n">lims</span> <span class="o">=</span> <span class="p">[(</span><span class="n">base</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">base</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r_limit</span><span class="o">/</span><span class="n">base</span><span class="p">)]</span>
    <span class="n">mask_peak</span> <span class="o">=</span> <span class="p">((</span><span class="n">peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">oversampling</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="p">(</span><span class="n">peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">oversampling</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">getRingMask</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">mask_peak</span><span class="p">,</span> <span class="n">outer</span><span class="p">,</span> <span class="n">inner</span><span class="p">)</span> <span class="k">for</span> <span class="n">outer</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">lims</span><span class="p">]</span>

    <span class="n">Ss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ms</span><span class="p">)):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">ms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">spin</span> <span class="o">=</span> <span class="n">radial_fct</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">phi</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">masks</span><span class="p">)):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">spin</span><span class="p">,</span> <span class="n">oversampling</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">Ss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

    <span class="c1"># TODO: make Ss sparse and split real and imaginary part</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ss</span><span class="p">)</span></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Fred Moolekamp and Peter Melchior.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>